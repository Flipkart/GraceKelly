{"name":"Gracekelly","tagline":"A Best Effort Cache Synchronization Library In Java","body":"#GraceKelly\r\n####a best effort cache synchronization library for distributed systems\r\n\r\nGraceKelly is a best effort cache synchronization library designed to\r\nshield distributed systems and services from direct exposure to\r\nunpredictable request loads. It improves load and response SLA\r\npredictability in distributed environments. It also enables graceful\r\ndegradation with stale data as fallback, in a degraded distributed\r\necosystem.\r\n\r\n##Why is it needed?\r\n\r\n####A chaotic place\r\n\r\nAny big distributed environment is inherently\r\ncomplex and chaotic. This complexity arises due to the complex\r\ndependencies between different services. The variability of the\r\nrequests and responses that this environment is exposed to makes it a\r\nchaotic place\r\n\r\n<img src=\"https://img3a.flixcart.com//www/promos/new/20130905-115236-soa.png\">\r\n\r\nThis chaos means the predictability of load and latency is\r\nreduced. This makes the environment and it’s SLAs vulnerable to\r\narbitrary request loads. It’s necessary to shield the environment from\r\nsuch externally induced unpredictability. Since service SLAs are\r\naffected by service load, such shielding also ensures their\r\npredictability. This means, one must systemically strive to hold on to\r\nas much predictability as possible when building a service/system.\r\n\r\n####Sheilds up\r\n\r\nCaches act as sentinels in an distributed environment. Although their\r\nprimary function is to reduce latency, when used appropriately they\r\nexcel at bringing predictability to a system. That’s because a cache\r\nrequest is extremely predictable, with almost no variability, either\r\nin response times or the load per request. One could say that there is\r\npositive co-relation between the percentage of Cache hits and the\r\npredictability of a system/environment.\r\n\r\n<img src=\"https://img1a.flixcart.com//www/promos/new/20130905-115342-soa-cached.png\">\r\n\r\n####Cache expiry\r\n\r\nEvery time there is a cache miss the environment and SLAs become a\r\nlittle bit more vulnerable. In this context, the common cache usage\r\npattern of expiry based on a ttl and subsequent re-population seems\r\nrisky. Using cache expiry as a proxy/trigger for cache synchronization\r\nexposes the underlying system to potentially harmful request pattern\r\nload for the duration of synchronization.\r\n\r\n- **t0** – a heavily requested cache entry c1 expires\r\n- **t1** – there is a cache miss for c1 and a request is sent to the service to fulfill\r\n- **t2** – the cache has been repopulated with c2\r\n\r\nThe time between **t1** and **t2** is the duration of exposure. The\r\npredictability of the target service and all the services it depends\r\non during this time is affected by the the per request load and the\r\nqps of all requests that result in a cache miss for c1.\r\n\r\n<img src=\"https://img1a.flixcart.com//www/promos/new/20130906-135948-cache-expiry.jpg\" style=\"background-color: #fff;\">\r\n\r\nWhat would be good to have is a cache library with regular caching\r\nsemantics but one that accommodates refreshing a cache entry rather\r\nthan expiring it based on ttl. This is exactly what GraceKelly is,\r\nit’s inspired by Gooogle Guava’s LoadingCache.\r\n\r\n##What does it do?\r\n\r\nGraceKelly tries it’s best to refresh the cache entry that has\r\nexpired. The refresh lifecycle is purely request triggered and doesn’t\r\nmonitor/maintain the cache. For every request\r\n\r\n- It looks up the cache and returns the value if a cache entry is present.\r\n- If the returned cache entry has expired it dispatches a task to refresh the cache entry.\r\n- If for some reason the refresh fails, it can extend the ttl of the existing entry or do nothing.\r\n\r\nNote that a cache entry is never removed(though it can be evicted by\r\nsize constraints).\r\n\r\nThis does two things.\r\n\r\n- Shields the backend services and systems from exposure to unnecessary request load.  \r\n- Decouples response SLAs from backend degradation and availability concerns, there by allowing for graceful degradation with stale data as fallback.\r\n\r\n<img src=\"https://img1a.flixcart.com//www/promos/new/20130906-135939-cache-refresh.jpg\" style=\"background-color: #fff;\">\r\n\r\n##The Library\r\n\r\nThe library has a single Class **Kelly** that takes implementations of\r\ntwo different interfaces a **CacheProvider** and a\r\n**CacheLoader**. They pass around a **CacheEntry**\r\n\r\n####Kelly\r\n\r\nKelly is the primary class for Gracekelly that reloads cacheEntries when they expire.\r\nIt has a very simple interface for usage.\r\n\r\n```java\r\n    /**\r\n    * obtain an instance of a CacheProvider implementation\r\n    * here the RemoteCache can be a wrapper to some kind of\r\n    * memcached client.\r\n    */\r\n    CacheProvider<CachedObject> cacheProvider = new RemoteCache();\r\n\r\n    /**\r\n    * obtain an instance of a CacheLoader implementation\r\n    */\r\n    CacheLoader<CachedObject> cacheLoader = new MyCacheLoader();\r\n\r\n    /**\r\n    * Fix the threadpool size for the number of threads that will\r\n    * be used to reload cache entries\r\n    */\r\n    Integer threadPoolSize = 10;\r\n\r\n    /**\r\n    * Create a kelly reloading cache instance with the provided\r\n    * cacheProvider, cacheLoader and threadPoolSize\r\n    */\r\n    Kelly<CachedObject> cache = new Kelly(cacheProvider, cacheLoader, threadPoolSize);\r\n\r\n    String key = \"sample_key\";\r\n    CachedObject value = new CachedObject();\r\n    long expiryTtl = 300;\r\n\r\n    /**\r\n    * Create a CacheEntry instance with the given\r\n    * key, value and ttl for expiry\r\n    */\r\n    CacheEntry cacheEntry = new CacheEntry(key, value, expiryTtl);\r\n\r\n    //put a CacheEntry in Cache\r\n    cache.put(key, cacheEntry);\r\n\r\n    //get value from cache\r\n    CachedObject cachedValue = cache.get(key);\r\n\r\n    //expire a cache key\r\n    cache.expire(key); //doesn't remove from cache\r\n```\r\n\r\nOne has to note that expired entries are not replaced as soon as they have expired but\r\nan attempt is made to refresh them using the CacheLoader the first time an expired\r\nCacheEntry is encountered during a get request.\r\n\r\n####CacheProvider\r\n\r\nThe CacheProvider interface is used to implement adapters to different cache implementations where the cached values\r\nare finally persisted and retrieved from. For eg: one would implement a CacheProvider for couchbase or memcached.\r\n\r\n\r\n```java\r\n\r\npublic interface CacheProvider <T>{\r\n    /**\r\n     * Returns a {@link CacheEntry}<T> if it is present in the underlying cache,\r\n     * or it returns a null otherwise.\r\n     * @param key\r\n     * @return {@link CacheEntry}<T> for the given key or return null if not present\r\n     * @throws CacheProviderException\r\n     */\r\n    CacheEntry<T> get(String key) throws CacheProviderException;\r\n\r\n    /**\r\n     * Tries to update the cache with the given {@link CacheEntry}<T> for the given key\r\n     * @param key\r\n     * @param value\r\n     * @return true or false based on the success of putting the {@link CacheEntry}<T>\r\n     * into the cache.\r\n     * @throws CacheProviderException\r\n     */\r\n    Boolean put(String key, CacheEntry<T> value) throws CacheProviderException;\r\n}\r\n```\r\n\r\nA trivial CacheProvider implementation for a local cache with a ConcurrentHashMap\r\ncould look like the following.\r\n\r\n```java\r\n\r\n    public class LocalCacheProvider implements CacheProvider<String>{\r\n\r\n        private final Map<String,CacheEntry<String>> cache = new ConcurrentHashMap<String,CacheEntry<String>>();\r\n\r\n        @Override\r\n        public CacheEntry<String> get(String key) throws CacheProviderException {\r\n            return cache.get(\"key\");\r\n        }\r\n\r\n        @Override\r\n        public Boolean put(String key, CacheEntry<String> value) throws CacheProviderException {\r\n            cache.put(key,value);\r\n            return true;\r\n        }\r\n    }\r\n```\r\n\r\n####CacheLoader\r\n\r\nThe CacheLoader provides a single method to reload cache, based on an existing entry in the cache.\r\nThe implementation of CacheLoader should be able to reload the cache given the key of the and the\r\nprevious value of the CacheEntry.\r\n\r\n```java\r\npublic interface CacheLoader<T> {\r\n\r\n    /**\r\n     * Takes a {@link String} key and a value/Object of type <T> and returns a\r\n     * {@link CacheEntry}<T>. The implementation of this method is supposed to\r\n     * return the CacheEntry with the latest Value for the given key.\r\n     * @param key\r\n     * @param prevValue\r\n     * @return {@link CacheEntry} of the type parameter specified during\r\n     * declaration of this instance of CacheLoader\r\n     * @throws CacheLoaderException\r\n     */\r\n    public CacheEntry<T> reload(String key, T prevValue) throws CacheLoaderException;\r\n}\r\n```\r\n\r\n####CacheEntry\r\nThe CacheEntry class is a simple java object that holds data required to get, put and invalidate a\r\ncache entry. The generic parameter indicates the type of the object that will be stored against the\r\ngiven key. usage is as follows, where the **ttl is in seconds**\r\n\r\n```java\r\n//cache entry valid for 5 minutes since time of creation\r\nCacheEntry<CachedObject> cacheEntry = new CacheEntry<CachedObject>(\"key\", someObject, 300);\r\n\r\nString key = cacheEntry.getKey() //returns the key of the CacheEntry\r\nCachedObject = cahceEntry.getValue() //returns value of the CacheEntry\r\nlong ttl = cacheEntry.getTtl() //returns the ttl in seconds\r\n```\r\n\r\n##Maven Artifact\r\n\r\nAdd the following repository to your pom.xml\r\n\r\n```xml\r\n    <repository>\r\n      <id>clojars</id>\r\n      <name>Clojars repository</name>\r\n      <url>https://clojars.org/repo</url>\r\n    </repository>\r\n```\r\n\r\nAnd add the following dependency to start using GraceKelly in your maven project.\r\n\r\n```xml\r\n   <dependency>\r\n     <groupId>com.flipkart.lego</groupId>\r\n     <artifactId>gracekelly</artifactId>\r\n     <version>1.2.1</version>\r\n   </dependency>\r\n```\r\n\r\n##Documentation\r\n\r\nThe api docs can be found [here](http://flipkart.github.io/GraceKelly/docs/index.html)\r\n\r\n##Contribution, Bugs and Feedback\r\n\r\nFor bugs, questions and discussions please use the [Github Issues](https://github.com/Flipkart/GraceKelly/issues).\r\nPlease follow the [contribution guidelines](https://github.com/Flipkart/GraceKelly/blob/master/CONTRIBUTING.md) when submitting pull requests.\r\n\r\n\r\n##License\r\n\r\nCopyright 2013 Flipkart Internet, pvt ltd.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\nhttp://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n\r\n","google":"UA-43777098-1","note":"Don't delete this file! It's used internally to help with page regeneration."}